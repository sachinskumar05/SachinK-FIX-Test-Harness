import org.gradle.api.artifacts.ProjectDependency

plugins {
    id 'base'
}

ext {
    versions = [
        junit    : '5.10.2',
        junitPlatform: '1.10.2',
        jackson  : '2.17.2',
        picocli  : '4.7.6',
        javalin  : '6.2.0',
        micrometer: '1.13.2'
    ]
}

allprojects {
    group = rootProject.findProperty('group')
    version = rootProject.findProperty('version')
}

subprojects { p ->
    if (p.name != 'app-ui') {
        apply plugin: 'java-library'


        tasks.withType(JavaCompile).configureEach {
            options.encoding = 'UTF-8'
            options.release = 17
        }

        dependencies {
            testImplementation "org.junit.jupiter:junit-jupiter-api:${rootProject.ext.versions.junit}"
            testRuntimeOnly "org.junit.jupiter:junit-jupiter-engine:${rootProject.ext.versions.junit}"
            testRuntimeOnly "org.junit.platform:junit-platform-launcher:${rootProject.ext.versions.junitPlatform}"
        }

        tasks.withType(Test).configureEach {
            useJUnitPlatform()
        }

        tasks.register('formatFix') {
            def pDir = project.layout.projectDirectory.asFile
            def targetFiles = project.fileTree(pDir) {
                include 'src/**/*.java', '*.gradle', '*.md'
                exclude 'build/**'
            }
            group = 'verification'
            description = 'Fixes minimal formatting guards.'
            doLast {
                targetFiles.each { file ->
                    def text = file.getText('UTF-8')
                    def lines = text.split('\r?\n', -1)
                    def newLines = lines.collect { it.replaceAll(/[ \t]+$/, '') }
                    // Re-join with the original line ending style, or enforce LF. 
                    // To be safe and satisfy formatCheck, we use LF since formatCheck checks for \n.
                    def newText = newLines.join('\n')
                    // Ensure EOF newline
                    if (!newText.endsWith('\n')) {
                        newText += '\n'
                    }
                    if (text != newText) {
                        file.write(newText, 'UTF-8')
                        println "Fixed format for ${file}"
                    }
                }
            }
        }

        tasks.register('formatCheck') {
            def pDir = project.layout.projectDirectory.asFile
            def targetFiles = project.fileTree(pDir) {
                include 'src/**/*.java', '*.gradle', '*.md'
                exclude 'build/**'
            }
            group = 'verification'
            description = 'Applies minimal formatting guards (no trailing whitespace, newline at EOF).'
            doLast {
                targetFiles.each { file ->
                    def text = file.getText('UTF-8')
                    def lines = text.split('\\r?\\n', -1)
                    lines.eachWithIndex { line, idx ->
                        if (line ==~ /.*[ \t]+$/) {
                            throw new GradleException("Trailing whitespace in ${file}:${idx + 1}")
                        }
                    }
                    if (!text.endsWith('\n')) {
                        throw new GradleException("Missing newline at EOF in ${file}")
                    }
                }
            }
        }

        tasks.named('check') {
            dependsOn tasks.named('formatCheck')
        }

        configurations.configureEach { cfg ->
            cfg.withDependencies { deps ->
                deps.withType(ProjectDependency).each { dep ->
                    if (!p.name.startsWith('app-') && dep.path.startsWith(':app-')) {
                        throw new GradleException("Illegal dependency direction: ${p.path} -> ${dep.path}")
                    }
                }
            }
        }
    }
}

project(':app-ui') {
    apply plugin: 'base'
}
